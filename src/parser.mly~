/* parser.mly */

%{

open Location

module A = Absyn
module S = Symbol

let pos n x = mkloc { loc_start = Parsing.rhs_start_pos n;
                      loc_end = Parsing.rhs_end_pos n;
                    }
                    x

let loc x = mkloc { loc_start = Parsing.symbol_start_pos ();
                    loc_end = Parsing.symbol_end_pos ();
                  }
                  x

let mkexp e = loc (e, ref Types.UNIT)

let parse_error msg =
  match !lexbuf_ref with
  | Some lexbuf ->
      Error.error (curr_loc lexbuf) (Error.Syntax (Lexing.lexeme lexbuf))
  | None ->
      Error.internal "lexbuf_ref is unset"

%}

%token <int>    INT
%token <string> STRING
%token <string> ID
%token          FOR WHILE BREAK LET IN NIL TO END
%token          FUNCTION VAR TYPE ARRAY IF THEN ELSE DO OF
%token          LPAREN RPAREN LBRACK RBRACK LBRACE RBRACE
%token          DOT COLON COMMA SEMI
%token          PLUS MINUS TIMES DIV UMINUS
%token          EQ NE LT LE GT GE
%token          AND OR
%token          ASSIGN
%token          EOF

%nonassoc ELSE DO

%nonassoc ASSIGN
%left OR
%left AND
%nonassoc EQ NE LT LE GT GE
%left PLUS MINUS
%left TIMES DIV
%nonassoc UMINUS

%start prog
%type <Absyn.lexp> prog

%%

prog:
  exp                                              { $1 }
;

exp:

  NIL                                              { mkexp A.NilExp }
| INT                                              { mkexp (A.IntExp $1) }
| STRING                                           { mkexp (A.StringExp $1) }

| id LBRACK exp RBRACK OF exp                      { mkexp (A.ArrayExp ($1, $3, $6)) }
/*
| id LBRACE field_value_list RBRACE                { mkexp (A.RecordExp ($1, $3)) }
*/

| lvalue                                           { mkexp (A.VarExp $1) }

| lvalue ASSIGN exp                                { mkexp (A.AssignExp ($1, $3)) }

| id LPAREN args RPAREN                            { mkexp (A.CallExp ($1, $3)) }

| exp OR exp                                       { mkexp (A.OpExp (A.OrOp, $1, $3)) }
| exp AND exp                                      { mkexp (A.OpExp (A.AndOp, $1, $3)) }
| exp EQ exp                                       { mkexp (A.OpExp (A.EqOp, $1, $3)) }
| exp NE exp                                       { mkexp (A.OpExp (A.NeOp, $1, $3)) }
| exp LT exp                                       { mkexp (A.OpExp (A.LtOp, $1, $3)) }
| exp LE exp                                       { mkexp (A.OpExp (A.LeOp, $1, $3)) }
| exp GT exp                                       { mkexp (A.OpExp (A.GtOp, $1, $3)) }
| exp GE exp                                       { mkexp (A.OpExp (A.GeOp, $1, $3)) }
| exp PLUS exp                                     { mkexp (A.OpExp (A.PlusOp, $1, $3)) }
| exp MINUS exp                                    { mkexp (A.OpExp (A.MinusOp, $1, $3)) }
| exp TIMES exp                                    { mkexp (A.OpExp (A.TimesOp, $1, $3)) }
| exp DIV exp                                      { mkexp (A.OpExp (A.DivideOp, $1, $3)) }
| MINUS exp %prec UMINUS                           { mkexp (A.OpExp (A.MinusOp, mkexp (A.IntExp 0), $2)) }

| IF exp THEN exp ELSE exp                         { mkexp (A.IfExp ($2, $4, Some $6)) }
| IF exp THEN exp                                  { mkexp (A.IfExp ($2, $4, None)) }
| WHILE exp DO exp                                 { mkexp (A.WhileExp ($2, $4)) }
| FOR id ASSIGN exp TO exp DO exp                  { mkexp (A.ForExp ($2, ref true, $4, $6, $8)) }
| BREAK                                            { mkexp A.BreakExp }

| LET decs IN sequence END                         { mkexp (A.LetExp ($2, $4)) }

| LPAREN sequence RPAREN                           { $2 }
;

id:
  ID                                               { S.symbol $1 }
;

field_value_list:
  id EQ exp                                        { [loc ($1, $3)] }
| id EQ exp COMMA field_value_list                 { loc ($1, $3) :: $5 }
;

lvalue:
  id                                               { loc (A.SimpleVar $1) }
/*| id DOT id                                    { loc (A.FieldVar (loc (A.SimpleVar $1)), $3) }*/
| lvalue DOT id                                    { loc (A.FieldVar ($1, $3)) }
/*| id LBRACK exp RBRACK                         { loc (A.SubscriptVar (loc (A.SimpleVar $1)), $3) }*/
| lvalue LBRACK exp RBRACK                         { loc (A.SubscriptVar ($1, $3)) }
;

field:
  id COLON id                                      { loc ($1, ref true, $3) }
;

fields:
  /* empty */                                      { [] }
| field fields_rest                                { $1 :: $2 }
;

fields_rest:
  /* empty */                                      { [] }
| COMMA field fields_rest                          { $2 :: $3 }
;

sequence:
  /* empty */                                      { mkexp (A.SeqExp []) }
| exp                                              { $1 }
| exp SEMI sequence_rest                           { mkexp (A.SeqExp ($1 :: $3)) }
| error SEMI sequence_rest                         { mkexp (A.SeqExp ($3)) }
;

sequence_rest:
  exp                                              { $1 :: [] }
| exp SEMI sequence_rest                           { $1 :: $3 }
| error SEMI sequence_rest                         { $3 }
;

args:
  /* empty */                                      { [] }
| exp                                              { $1 :: [] }
| exp COMMA args_rest                              { $1 :: $3 }
| error COMMA args_rest                            { $3 }
;

args_rest:
  exp                                              { $1 :: [] }
| exp COMMA args_rest                              { $1 :: $3 }
| error COMMA args_rest                            { $3 }
;



type_opt:
  COLON id                                         { Some (loc $2) }
|                                                  { None }
;

varDec:
  VAR id type_opt ASSIGN exp                       { loc (A.VarDec ($2, ref true, $3, $5, ref Types.UNIT)) }
;

functionDec:
  FUNCTION id LPAREN fields RPAREN type_opt EQ exp { loc ($2, $4, $6, $8, ref Types.UNIT) }
;

typeDec:
  TYPE id EQ ty                                    { loc ($2, $4) }
;



ty:
  id                                               { loc (A.NameTy $1) }
| LBRACE fields RBRACE                             { loc (A.RecordTy $2) }
| ARRAY OF id                                      { loc (A.ArrayTy (pos 3 $3)) }
;



decs:
  begVarDecList                       { $1 }
| begFunctionDecList                  { $1 }
| begTypeDecList                      { $1 }
;

begVarDecList:
  varDec                              { $1 :: [] }
| varDec begVarDecList                { $1 :: $2 }
| varDec begFunctionDecList           { $1 :: $2 }
| varDec begTypeDecList               { $1 :: $2 }
;

begTypeDecList:
  mutual_type_decs                    { $1 :: [] }
| mutual_type_decs begVarDecList      { $1 :: $2 }
| mutual_type_decs begFunctionDecList { $1 :: $2 }
;

begFunctionDecList:
  mutual_function_decs                { $1 :: [] }
| mutual_function_decs begVarDecList  { $1 :: $2 }
| mutual_function_decs begTypeDecList { $1 :: $2 }
;

mutual_type_decs:
  typeDecs                            { loc (A.MutualTypDecs $1) }
;

mutual_function_decs:
  functionDecs                        { loc (A.MutualFunDecs $1) }
;

typeDecs:
  typeDec typeDecs                    { $1 :: $2 }
| typeDec                             { $1 :: [] }
;

functionDecs:
  functionDec functionDecs            { $1 :: $2 }
| functionDec                         { $1 :: [] }
;


/*
decs:
                            { [] }
| dec decs                  { $1 :: $2 }
;

dec:
  varDec                    { $1 }
| mutualFunDecs             { loc (A.MutualFunDecs $1) }
| mutualTypDecs             { loc (A.MutualTypDecs $1) }
;

// these rules give a shift/reduce conflict on FUNCTION
mutualFunDecs:
  functionDec               { $1 :: [] }
| functionDec mutualFunDecs { $1 :: $2 }
;

// these rules give a shift/reduce conflict on TYPE
mutualTypDecs:
  typeDec                   { $1 :: [] }
| typeDec mutualTypDecs     { $1 :: $2 }
;
*/

%%
