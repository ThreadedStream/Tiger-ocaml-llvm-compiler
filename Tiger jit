; ModuleID = 'Tiger jit'
source_filename = "Tiger jit"

@0 = private unnamed_addr constant [6 x i8] c"hello\00"
@1 = private unnamed_addr constant [6 x i8] c"world\00"
@2 = private unnamed_addr constant [11 x i8] c"record.tig\00"
@3 = private unnamed_addr constant [11 x i8] c"record.tig\00"

declare void @tig_print_int(i32)

declare void @tig_print(i8*)

declare void @print_arr_int_ele(i32)

declare i32* @tig_init_array(i32, i32)

declare i32* @tig_init_record(i32)

declare i32 @tig_array_length(i8*)

declare i32 @tig_nillable(i8*)

declare void @tig_check_array_bound(i8*, i32, i8*)

declare i32 @tig_random(i32)

declare void @tig_exit(i32)

declare void @tig_flush()

declare i8* @tig_getchar()

declare i32 @tig_ord(i8*)

declare i8* @tig_chr(i32)

declare i32 @tig_string_cmp(i8*, i8*)

declare i32 @tig_size(i8*)

declare i8* @tig_substring(i8*, i32, i32)

declare i8* @tig_concat(i8*, i8*)

declare i32 @tig_not(i32)

declare void @assert_equal_int(i8*, i32, i32)

declare void @assert_equal_string(i8*, i8*, i8*)

define i32 @main() {
entry:
  %student = alloca { i8*, { i8*, i32 }* }*
  %class = alloca { i8*, i32 }*
  %frame_pointer = alloca { i32 }
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8*, i32 }* getelementptr ({ i8*, i32 }, { i8*, i32 }* null, i32 1) to i32))
  %record_init = bitcast i8* %malloccall to { i8*, i32 }*
  %Element = getelementptr { i8*, i32 }, { i8*, i32 }* %record_init, i32 0, i32 0
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @0, i32 0, i32 0), i8** %Element
  %Element1 = getelementptr { i8*, i32 }, { i8*, i32 }* %record_init, i32 0, i32 1
  store i32 10, i32* %Element1
  store { i8*, i32 }* %record_init, { i8*, i32 }** %class
  %class2 = load { i8*, i32 }*, { i8*, i32 }** %class
  %malloccall3 = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i64), i64 2) to i32))
  %record_init4 = bitcast i8* %malloccall3 to { i8*, { i8*, i32 }* }*
  %Element5 = getelementptr { i8*, { i8*, i32 }* }, { i8*, { i8*, i32 }* }* %record_init4, i32 0, i32 0
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @1, i32 0, i32 0), i8** %Element5
  %Element6 = getelementptr { i8*, { i8*, i32 }* }, { i8*, { i8*, i32 }* }* %record_init4, i32 0, i32 1
  store { i8*, i32 }* %class2, { i8*, i32 }** %Element6
  store { i8*, { i8*, i32 }* }* %record_init4, { i8*, { i8*, i32 }* }** %student

break_loop:                                       ; No predecessors!
  ret i32 0
}

declare noalias i8* @malloc(i32)

define void @assert_string({ i32 }*, i8*, i8*) {
entry:
  %expected = alloca i8*
  %actual = alloca i8*
  %frame_pointer = alloca { { i32 }* }
  %arg_address = getelementptr { { i32 }* }, { { i32 }* }* %frame_pointer, i32 0, i32 0
  store { i32 }* %0, { i32 }** %arg_address
  store i8* %1, i8** %actual
  store i8* %2, i8** %expected
  %actual1 = load i8*, i8** %actual
  %expected2 = load i8*, i8** %expected
  call void @assert_equal_string(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @2, i32 0, i32 0), i8* %actual1, i8* %expected2)
  ret void
}

define void @assert_int({ i32 }*, i32, i32) {
entry:
  %expected = alloca i32
  %actual = alloca i32
  %frame_pointer = alloca { { i32 }* }
  %arg_address = getelementptr { { i32 }* }, { { i32 }* }* %frame_pointer, i32 0, i32 0
  store { i32 }* %0, { i32 }** %arg_address
  store i32 %1, i32* %actual
  store i32 %2, i32* %expected
  %actual1 = load i32, i32* %actual
  %expected2 = load i32, i32* %expected
  call void @assert_equal_int(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @3, i32 0, i32 0), i32 %actual1, i32 %expected2)
  ret void
}
